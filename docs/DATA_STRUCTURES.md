# OPT-STM Data Structure Documentation

## Overview
This document describes all data structures used in the OPT-STM voxel-based mesh generation system, from geometry definition through to visualization.

## Core Data Structures

### 1. `voxel_grid` - 3D Boolean Array
**Type:** `numpy.ndarray`  
**Shape:** `(nx, ny, nz)` where nx, ny, nz are grid dimensions  
**Data Type:** `bool`  
**Example:** `(35, 11, 83)` = 31,955 total voxels, 14,262 active (True values)

**Purpose:** Represents the 3D spatial grid indicating which voxels are inside the geometry (True) or outside (False).

**Creation:** Generated by ray-casting algorithm in `_compute_voxel_occupancy()` method.

**Deduplication:** Not applicable (boolean array).

---

### 2. `nodes` - Node Coordinates
**Type:** `numpy.ndarray`  
**Shape:** `(N, 3)` where N is the total number of mesh nodes  
**Data Type:** `float64`  
**Example:** `(17,080, 3)` for corbel model

**Purpose:** Stores the (x, y, z) coordinates of all mesh nodes. Each row represents one node.

**Creation:** Generated in `generate_node_element_connectivity()` by iterating through active voxels and creating nodes at voxel corners.

**Deduplication:** Guaranteed by construction using Python `set()`:
```python
node_set = set()  # Collect unique (i,j,k) grid coordinates
# ... add nodes from all elements ...
node_list = sorted(node_set)  # Convert to sorted list
self.nodes = np.array([[x,y,z], ...])  # Create coordinate array
```
Since sets cannot contain duplicates, coincident nodes are impossible (within numerical precision).

**Verification:** The `_verify_no_coincident_nodes()` method confirms no nodes exist within tolerance:
- Tolerance: 5% of minimum voxel dimension (~1.67mm for 33.33mm voxels)
- Uses scipy.spatial.cKDTree for efficient O(N log N) spatial queries
- Result: Minimum distance = 33.33mm (one voxel spacing) ✓

---

### 3. `elements` - Element Connectivity
**Type:** `numpy.ndarray`  
**Shape:** `(M, 8)` where M is the total number of hex8 elements  
**Data Type:** `int`  
**Example:** `(14,262, 8)` for corbel model

**Purpose:** Defines hex8 finite element connectivity. Each row contains 8 node indices that define one hexahedral element.

**Node Ordering:** Hex8 standard ordering (see FEniCS/Abaqus conventions):
```
       7-------6
      /|      /|
     / |     / |
    4-------5  |
    |  3----|--2
    | /     | /
    |/      |/
    0-------1
```

**Creation:** Generated in `generate_node_element_connectivity()` alongside `nodes` array.

**Deduplication:** Elements are unique by construction (one element per active voxel).

---

### 4. `node_to_idx` - Grid-to-Node Mapping
**Type:** `dict`  
**Keys:** `tuple(int, int, int)` - Grid coordinates (i, j, k)  
**Values:** `int` - Node index in `nodes` array  
**Example:** `{(0,0,0): 0, (1,0,0): 1, (0,1,0): 2, ...}`

**Purpose:** Maps 3D grid coordinates to node indices for efficient element construction.

**Creation:** Generated during node creation:
```python
node_list = sorted(node_set)
self.node_to_idx = {(i,j,k): idx for idx, (i,j,k) in enumerate(node_list)}
```

**Deduplication:** Keys are unique grid coordinates, values are unique node indices.

---

### 5. `surface_nodes` - Boundary Node Indices
**Type:** `numpy.ndarray`  
**Shape:** `(K,)` where K is the number of surface nodes  
**Data Type:** `int`  
**Example:** `(5,500,)` for corbel model - sorted array of node indices

**Purpose:** Stores indices of nodes on the geometry boundary (nodes connected to <8 elements in structured mesh).

**Creation:** Generated in `_compute_surface_elements()`:
```python
boundary_nodes = self._get_boundary_nodes()  # Returns set of node indices
self.surface_nodes = np.array(sorted(list(boundary_nodes)))
```

**Deduplication:** Guaranteed by using `set()` for collection, then converting to sorted array.

**Usage:** Used for visualization (`_plot_voxels()`) to plot only surface nodes, avoiding the previous "double layer" issue.

---

### 6. `surface_elements` - Boundary Element Indices
**Type:** `numpy.ndarray`  
**Shape:** `(L,)` where L is the number of surface elements  
**Data Type:** `int`  
**Example:** `(4,939,)` for corbel model - 34.6% of total elements

**Purpose:** Stores indices of elements on the geometry boundary (elements with ≥4 boundary nodes).

**Creation:** Generated in `_compute_surface_elements()` by checking each element's node membership in `boundary_nodes` set.

**Deduplication:** Element indices are unique by construction.

**Usage:** Used for identifying which elements are near supports/loads, and for force positioning.

---

### 7. `surface_element_centers` - Element Center Coordinates
**Type:** `numpy.ndarray`  
**Shape:** `(L, 3)` where L is the number of surface elements  
**Data Type:** `float64`  
**Example:** `(4,939, 3)` for corbel model

**Purpose:** Stores the (x, y, z) coordinates of surface element centers (centroid of 8 nodes).

**Creation:** Computed in `_compute_surface_elements()`:
```python
element_nodes = self.nodes[element]  # Get 8 node coordinates
center = np.mean(element_nodes, axis=0)  # Average to get centroid
```

**Important Note:** Element centers are ~16.66mm (half voxel) inside the surface. This was the root cause of the "double layer" visualization bug that was fixed.

**Usage:** Used for positioning force arrows (forces applied at element centers), **NOT** for surface visualization.

---

### 8. `surface_normals` - Outward Normal Vectors
**Type:** `numpy.ndarray`  
**Shape:** `(L, 3)` where L is the number of surface elements  
**Data Type:** `float64`  
**Example:** `(4,939, 3)` for corbel model

**Purpose:** Stores outward-pointing unit normal vectors for each surface element, used for force arrow visualization.

**Creation:** Computed in `_compute_surface_normals()` by analyzing element faces and determining which face is on the boundary.

**Usage:** Defines direction of force arrows in 3D visualization.

---

## Data Structure Summary Table

| Structure | Type | Shape | Elements | Deduplication Method | Purpose |
|-----------|------|-------|----------|----------------------|---------|
| `voxel_grid` | ndarray (bool) | (nx, ny, nz) | 31,955 | N/A | Active voxel indicator |
| `nodes` | ndarray (float) | (N, 3) | 17,080 | `set()` → `sorted()` | Node coordinates |
| `elements` | ndarray (int) | (M, 8) | 14,262 | One per voxel | Hex8 connectivity |
| `node_to_idx` | dict | N/A | 17,080 | Unique keys | Grid→node mapping |
| `surface_nodes` | ndarray (int) | (K,) | 5,500 | `set()` → `sorted()` | Boundary node indices |
| `surface_elements` | ndarray (int) | (L,) | 4,939 | Element indices | Boundary element indices |
| `surface_element_centers` | ndarray (float) | (L, 3) | 4,939 | N/A | Element centroids |
| `surface_normals` | ndarray (float) | (L, 3) | 4,939 | N/A | Outward normals |

---

## Verification Results

### Coincident Node Check
**Tolerance:** 1.67mm (5% of 33.33mm voxel)  
**Method:** scipy.spatial.cKDTree spatial indexing  
**Complexity:** O(N log N)  
**Result:** ✅ **No coincident nodes found**  
**Minimum node spacing:** 33.33mm (exactly one voxel dimension)

This confirms that the mesh generation creates a perfect structured grid with no duplicate or overlapping nodes.

---

## Key Architectural Insights

### 1. Two-Stage Uniqueness Guarantee
The mesh generation uses a two-stage process to guarantee unique nodes:

**Stage 1 - Construction:**
```python
node_set = set()  # Python set ensures uniqueness
for voxel in active_voxels:
    for corner in voxel_corners:
        node_set.add((i, j, k))  # Grid coordinates
```

**Stage 2 - Verification:**
```python
self._verify_no_coincident_nodes()  # Spatial tolerance check
```

### 2. Surface vs. Element Centers
**Critical distinction** discovered during debugging:

- **Surface nodes** (`surface_nodes`): Actual geometry boundary - ON the surface (distance = 0.03mm from ideal plane)
- **Element centers** (`surface_element_centers`): Located ~16.66mm INSIDE surface (half voxel depth)

The original "double layer" visualization bug occurred because element centers were being plotted instead of surface nodes.

**Fix:** Changed `_plot_voxels()` to use `self.nodes[self.surface_nodes]` instead of `self.surface_element_centers`.

### 3. Structured Mesh Boundary Detection
Interior nodes connect to exactly 8 elements (full voxel neighborhood).  
Boundary nodes connect to <8 elements (incomplete neighborhood).  

This simple criterion works perfectly for structured hex meshes.

---

## Implementation Notes

### Memory Efficiency
- Arrays use NumPy for efficient storage
- Set-based deduplication during construction (not post-processing)
- KDTree uses O(N log N) space complexity

### Performance
- Mesh generation: ~1 second for 17,080 nodes
- Coincident check: ~0.1 seconds using KDTree
- Visualization: ~2 seconds (5,500 surface nodes)

### Numerical Precision
- Node coordinates: float64 (1e-15 relative precision)
- Coplanar tolerance: 1% of voxel (0.33mm for faces)
- Coincident tolerance: 5% of voxel (1.67mm for verification)

---

**Document Version:** 1.0  
**Last Updated:** Based on corbel example (33.33mm voxels)  
**Test Results:** All verifications passed ✓
